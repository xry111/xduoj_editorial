# Problem 1006: 亮亮破解密码

直接模拟的话时间复杂度
![](http://www.forkosh.com/mathtex.cgi?O(n^2))
，显然超时。注意到期望的线性性质，and、or和xor又是位运算，
显然可以把每一二进制位分开处理。

对于and操作，若区间[l,r]的and结果为1，其充要条件是
这个区间上所有数都为1。那么，对于以r结尾的区间，使得[l,r]
上的and结果为1的l的个数就是以r结尾的最长的全是1的区间的长
度l1[r]。显然l1满足递推关系：

```
l1[r] = l1[r-1]+1 (第r个数为1)
l1[r] = 0 (第r个数为0)
```

因此，只要用O(n)的时间从左到右扫一次，就能推出每个元素结尾
的区间中，结果为1的区间的个数。考虑l、r不相等时交换次序的情况，
真实的答案还要乘以2再减掉位置r本身的数（l，r相等的情况）。
将所有结果加起来，除以
![](http://www.forkosh.com/mathtex.cgi?O(n^2))
，就是这一位的结果为1的概率。

对于or操作，若区间[l,r]的or结果为0，其充要条件是这个区间
上所有的数都是0。那么，对于以r结尾的区间，使得[l,r]上or
结果为0的l的个数是以r结尾的最长的全为0的区间的长度l0[r]，即使得
结果为1的l的个数为r-l0[r]。显然l0满足递推关系：

```
l0[r] = l0[r-1]+1 (第r个数为0)
l0[r] = 0 (第r个数为1)
```

同样要考虑交换次序的情况，和求and的结果是完全类似的。

对于xor操作，用cnt[r]表示使得[l,r]上xor结果为1的l的个数，则
根据xor操作“反向”的性质，cnt[r]也有一个递推关系：

```
cnt[r] = r-cnt[r-1] (第r个数为1)
cnt[r] = cnt[r-1] (第r个数为0)
```

仍然要考虑交换顺序的情况。

总的时间复杂度O(nloga)。
