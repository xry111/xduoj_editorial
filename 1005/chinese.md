# Problem 1005: xry111的音频传输

## 问题描述

有一个集合S包含n个元素，要从中找到一个唯一的具有性质X的元素A。
每次查询可以选择S的一个子集，并一次性确定A是否属于该子集，问
最少查询多少次。

## 正解

对于n个元素，将其编号为0...n-1，并转为二进制。设去除先导零后
最长的编号有k位，则对于第0...k-1位，选出这一位编号为1的元素组成
一个子集进行查询。k次查询后，就确定了A的编号的每一位是0还是1,
也就锁定了元素A。所以问题就是求n-1的二进制表示的位数，即
![](http://www.forkosh.com/mathtex.cgi?\\lceil log_2 n \\rceil)
。

由于double的精度只有二进制52位（相当于十进制15位），直接使用math.h
的浮点log函数会造成严重的误差，不保证可以通过测试。正确解法是用短除
法，直接求n-1的二进制表示的位数，时间复杂度为O(logn)。还可以用二分
查找优化到O(loglogn)，不过这太丧心病狂了。

## 其他解
二分法，每次随便选S的一半T去查询，若A属于T就对T继续查询，否则对S\T
继续查询，结果也是
![](http://www.forkosh.com/mathtex.cgi?\\lceil log_2 n \\rceil)
。但是这种解法碰到更严格的背景就抓瞎了，例如UVa11986。
